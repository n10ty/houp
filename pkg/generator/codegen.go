package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"
)

// GenerateValidation generates validation code for a struct
func GenerateValidation(structInfo *StructInfo, pkgName string, opts *GenerateOptions) (string, error) {
	ctx := &CodeGenContext{
		Struct:  structInfo,
		Imports: make(map[string]string),
		Buffer:  []string{},
		Options: opts,
	}

	// Always add fmt import for error messages
	ctx.AddImport("fmt", "fmt")

	// Generate validation method
	if err := generateValidateMethod(ctx); err != nil {
		return "", err
	}

	// Build final source code
	var buf bytes.Buffer

	// Header comment
	buf.WriteString("// Code generated by validgen. DO NOT EDIT.\n\n")

	// Package declaration
	buf.WriteString(fmt.Sprintf("package %s\n\n", pkgName))

	// Imports
	if len(ctx.Imports) > 0 {
		buf.WriteString("import (\n")
		for path, alias := range ctx.Imports {
			if alias == "" || alias == path[strings.LastIndex(path, "/")+1:] {
				buf.WriteString(fmt.Sprintf("\t%q\n", path))
			} else {
				buf.WriteString(fmt.Sprintf("\t%s %q\n", alias, path))
			}
		}
		buf.WriteString(")\n\n")
	}

	// Generated code
	for _, line := range ctx.Buffer {
		buf.WriteString(line)
		buf.WriteString("\n")
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted code with error for debugging
		return buf.String(), fmt.Errorf("failed to format generated code for struct %s in package %s: %w", structInfo.Name, pkgName, err)
	}

	return string(formatted), nil
}

// generateValidateMethod generates the Validate() method for a struct
func generateValidateMethod(ctx *CodeGenContext) error {
	receiverVar := strings.ToLower(string(ctx.Struct.Name[0]))

	// Method signature
	ctx.Buffer = append(ctx.Buffer, fmt.Sprintf("func (%s *%s) Validate() error {", receiverVar, ctx.Struct.Name))

	// Generate validation code for each field
	for _, field := range ctx.Struct.Fields {
		if err := generateFieldValidation(ctx, field); err != nil {
			return fmt.Errorf("failed to generate validation for field %s: %w", field.Name, err)
		}
	}

	// Return nil on success
	ctx.Buffer = append(ctx.Buffer, "\treturn nil")
	ctx.Buffer = append(ctx.Buffer, "}")

	return nil
}

// generateFieldValidation generates validation code for a single field
func generateFieldValidation(ctx *CodeGenContext, field *FieldInfo) error {
	// Validate rules first
	if err := ValidateRules(field, ctx.Options.UnknownTagMode); err != nil {
		if ctx.Options.UnknownTagMode == "skip" {
			// Log warning and skip this field
			fmt.Printf("Warning: struct '%s': %v\n", ctx.Struct.Name, err)
			return nil
		}
		return err
	}

	// Check if field has omitempty
	hasOmitEmpty := HasOmitEmpty(field.Rules)
	otherRules := GetNonOmitEmptyRules(field.Rules)

	// Filter out unknown rules in skip mode
	if ctx.Options.UnknownTagMode == "skip" {
		filtered := make([]ValidationRule, 0, len(otherRules))
		for _, rule := range otherRules {
			if _, ok := rule.(*UnknownRule); !ok {
				filtered = append(filtered, rule)
			}
		}
		otherRules = filtered
	}

	if len(otherRules) == 0 {
		return nil
	}

	// Add comment for field
	ctx.Buffer = append(ctx.Buffer, fmt.Sprintf("\t// %s: %s", field.Name, extractTag(field.Tag, "validate")))

	// Generate wrapper for omitempty if needed
	if hasOmitEmpty {
		if err := generateOmitEmptyWrapper(ctx, field, otherRules); err != nil {
			return err
		}
	} else {
		// Generate validations directly
		for _, rule := range otherRules {
			code, err := rule.Generate(ctx, field)
			if err != nil {
				return err
			}
			if code != "" {
				ctx.Buffer = append(ctx.Buffer, code)
			}
		}
	}

	return nil
}

// generateOmitEmptyWrapper wraps validations in an empty check
func generateOmitEmptyWrapper(ctx *CodeGenContext, field *FieldInfo, rules []ValidationRule) error {
	typeInfo := ResolveTypeInfo(field.Type, nil)
	receiverVar := strings.ToLower(string(ctx.Struct.Name[0]))

	// Generate appropriate empty check based on type
	var condition string

	if typeInfo.IsPointer {
		condition = fmt.Sprintf("%s.%s != nil", receiverVar, field.Name)
	} else if typeInfo.IsSlice {
		condition = fmt.Sprintf("%s.%s != nil && len(%s.%s) > 0", receiverVar, field.Name, receiverVar, field.Name)
	} else if typeInfo.Kind == TypeString {
		condition = fmt.Sprintf("%s.%s != \"\"", receiverVar, field.Name)
	} else if typeInfo.IsNumeric() {
		condition = fmt.Sprintf("%s.%s != 0", receiverVar, field.Name)
	} else {
		// For other types, skip omitempty
		condition = "true"
	}

	ctx.Buffer = append(ctx.Buffer, fmt.Sprintf("\tif %s {", condition))

	// Generate validations inside the if block
	for _, rule := range rules {
		code, err := rule.Generate(ctx, field)
		if err != nil {
			return err
		}
		if code != "" {
			// Indent the code one more level
			indentedCode := indentCode(code, 1)
			ctx.Buffer = append(ctx.Buffer, indentedCode)
		}
	}

	ctx.Buffer = append(ctx.Buffer, "\t}")

	return nil
}

// indentCode adds additional indentation to generated code
func indentCode(code string, levels int) string {
	indent := strings.Repeat("\t", levels)
	lines := strings.Split(code, "\n")
	for i, line := range lines {
		if line != "" {
			lines[i] = indent + line
		}
	}
	return strings.Join(lines, "\n")
}

// GenerateFileValidation generates validation code for all structs in a file
func GenerateFileValidation(fileInfo *FileInfo, pkgName string, opts *GenerateOptions) (string, error) {
	// Collect all structs that need validation
	var needsValidation []*StructInfo
	for _, structInfo := range fileInfo.Structs {
		if structInfo.NeedsGen {
			needsValidation = append(needsValidation, structInfo)
		}
	}

	if len(needsValidation) == 0 {
		return "", nil // No validation needed for this file
	}

	// Combine all struct validations
	allImports := make(map[string]string)
	var allMethods []string

	for _, structInfo := range needsValidation {
		// Regenerate with a combined context
		ctx := &CodeGenContext{
			Struct:  structInfo,
			Imports: allImports,
			Buffer:  []string{},
			Options: opts,
		}

		ctx.AddImport("fmt", "fmt")

		if err := generateValidateMethod(ctx); err != nil {
			return "", err
		}

		// Merge imports
		for path, alias := range ctx.Imports {
			allImports[path] = alias
		}

		// Add method to list
		allMethods = append(allMethods, strings.Join(ctx.Buffer, "\n"))
	}

	// Build final source
	var buf bytes.Buffer

	// Header
	buf.WriteString("// Code generated by validgen. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", pkgName))

	// Imports
	if len(allImports) > 0 {
		buf.WriteString("import (\n")
		for path, alias := range allImports {
			if alias == "fmt" && path == "fmt" {
				buf.WriteString("\t\"fmt\"\n")
			} else if alias == "" || alias == path[strings.LastIndex(path, "/")+1:] {
				buf.WriteString(fmt.Sprintf("\t%q\n", path))
			} else {
				buf.WriteString(fmt.Sprintf("\t%s %q\n", alias, path))
			}
		}
		buf.WriteString(")\n\n")
	}

	// Methods
	for i, method := range allMethods {
		if i > 0 {
			buf.WriteString("\n")
		}
		buf.WriteString(method)
		buf.WriteString("\n")
	}

	// Format
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Collect struct names for better error message
		structNames := make([]string, 0, len(needsValidation))
		for _, s := range needsValidation {
			structNames = append(structNames, s.Name)
		}
		return buf.String(), fmt.Errorf("failed to format generated code for structs [%s] in package %s: %w", strings.Join(structNames, ", "), pkgName, err)
	}

	return string(formatted), nil
}

// GenerateEmptyValidation generates an empty Validate() method for structs with dive but no own validations
func GenerateEmptyValidation(structName, pkgName string) string {
	receiverVar := strings.ToLower(string(structName[0]))

	var buf bytes.Buffer
	buf.WriteString("// Code generated by validgen. DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", pkgName))
	buf.WriteString(fmt.Sprintf("func (%s *%s) Validate() error {\n", receiverVar, structName))
	buf.WriteString("\treturn nil\n")
	buf.WriteString("}\n")

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return buf.String()
	}

	return string(formatted)
}
