# Houp - Static Validation Generator for Go

Houp is a code generation tool that automatically creates validation methods for Go structs based on struct tags. It provides compile-time safety and zero runtime reflection overhead.

## Features

- ✅ **Static Code Generation** - No runtime reflection
- ✅ **Comprehensive Validation Rules** - Support for all common validation patterns
- ✅ **Type-Safe** - Compile-time errors for mismatched validations
- ✅ **Zero Dependencies** - Generated code only depends on `fmt`
- ✅ **Nested Validation** - Deep validation with `dive` tag
- ✅ **Custom Validators** - Import and use your own validation functions
- ✅ **Unique Constraints** - Ensure uniqueness within slices
- ✅ **Regular Expressions** - Pattern matching with imported regexp variables
- ✅ **Flexible Error Handling** - Fail fast or collect all errors

## Installation

```bash
go install github.com/n10ty/houp/cmd/houp@latest
```

Or build from source:

```bash
git clone https://github.com/n10ty/houp.git
cd houp
go build -o houp ./cmd/houp
```

## Quick Start

### 1. Add validation tags to your structs

```go
package models

type User struct {
    ID       string   `json:"id" validate:"required"`
    Email    string   `json:"email" validate:"required,min=5"`
    Age      int      `json:"age" validate:"gte=18,lte=100"`
    Tags     []string `json:"tags" validate:"min=1,max=10,unique"`
    Profile  *Profile `json:"profile" validate:"required,dive"`
}

type Profile struct {
    Bio     string `json:"bio" validate:"required,max=500"`
    Website string `json:"website" validate:"omitempty,min=10"`
}
```

### 2. Generate validation code

```bash
houp ./models
```

This creates `user_validate.go`:

```go
// Code generated by houp. DO NOT EDIT.

package models

import "fmt"

func (u *User) Validate() error {
    if u.ID == "" {
        return fmt.Errorf("field ID is required")
    }
    if u.Email == "" {
        return fmt.Errorf("field Email is required")
    }
    if len(u.Email) < 5 {
        return fmt.Errorf("field Email must be at least 5 characters")
    }
    // ... more validation code
    return nil
}

func (p *Profile) Validate() error {
    // ... validation code
    return nil
}
```

### 3. Use in your code

```go
user := &User{
    ID:    "123",
    Email: "user@example.com",
    Age:   25,
}

if err := user.Validate(); err != nil {
    log.Printf("Validation failed: %v", err)
    return err
}
```

## Supported Validation Tags

| Tag | Description | Applicable Types | Example |
|-----|-------------|------------------|---------|
| `required` | Field must not be zero value | All types | `validate:"required"` |
| `omitempty` | Skip validation if field is empty | All types | `validate:"omitempty,min=5"` |
| `min=N` | Minimum value/length | Numbers, strings, slices | `validate:"min=1"` |
| `max=N` | Maximum value/length | Numbers, strings, slices | `validate:"max=100"` |
| `gt=N` | Greater than (exclusive) | Numbers | `validate:"gt=0"` |
| `lt=N` | Less than (exclusive) | Numbers | `validate:"lt=100"` |
| `gte=N` | Greater than or equal | Numbers | `validate:"gte=0"` |
| `lte=N` | Less than or equal | Numbers | `validate:"lte=100"` |
| `regexp=pkg:Var` | Match imported regexp | Strings | `validate:"regexp=github.com/x/y:Pattern"` |
| `unique` | Values must be unique | Slices | `validate:"unique"` |
| `unique=Field` | Field values must be unique (field must be string) | Slices of structs | `validate:"unique=Email"` |
| `dive` | Recursively validate | Structs, slices of structs | `validate:"dive"` |
| `pkg:Func` | Custom validator | Any type | `validate:"github.com/x/y:ValidateFn"` |

### Tag Combinations

Multiple tags can be combined with commas:

```go
type Product struct {
    Name  string  `validate:"required,min=3,max=100"`
    Price float64 `validate:"gt=0,lte=1000000"`
    Tags  []string `validate:"omitempty,min=1,max=5,unique"`
}
```

## Detailed Examples

### Basic Validation

```go
type BasicTypes struct {
    Name   string  `validate:"required,min=3,max=50"`
    Age    int     `validate:"gte=0,lte=150"`
    Email  string  `validate:"required"`
    Score  float64 `validate:"gt=0,lt=100"`
}
```

### Pointer Fields

```go
type PointerFields struct {
    Name  *string `validate:"required"`              // Must not be nil
    Age   *int    `validate:"omitempty,gt=0,lt=120"` // Validate only if not nil
}
```

### Slices

```go
type SliceValidation struct {
    Tags       []string `validate:"required,min=1,max=10"`   // Required, 1-10 elements
    Categories []string `validate:"omitempty,max=5"`         // Optional, max 5 elements
    IDs        []int    `validate:"unique"`                  // All values must be unique
}
```

### Unique Constraints

For **slices of scalars**, use `unique` without a field name:

```go
type ScalarUnique struct {
    Tags []string `validate:"unique"` // All tags must be unique
    IDs  []int    `validate:"unique"` // All IDs must be unique
}
```

For **slices of structs**, specify the field name (must be a string field):

```go
type User struct {
    ID    string `json:"id"`
    Email string `json:"email"`
}

type UserList struct {
    Users []User `validate:"unique=Email"` // All User.Email must be unique
}
```

### Nested Validation (Dive)

Use `dive` to validate nested structures:

```go
type Address struct {
    Street  string `validate:"required"`
    City    string `validate:"required"`
    ZipCode string `validate:"required,min=5,max=10"`
}

type Person struct {
    Name    string   `validate:"required"`
    Address *Address `validate:"required,dive"` // Validate Address is not nil AND valid
}
```

For slices:

```go
type Item struct {
    Name     string  `validate:"required"`
    Quantity int     `validate:"min=1"`
}

type Order struct {
    ID    string `validate:"required"`
    Items []Item `validate:"required,min=1,dive"` // Validate each item
}
```

You can combine `dive` with `unique`:

```go
type Order struct {
    Items []Item `validate:"min=1,dive,unique=SKU"` // Validate each + ensure unique SKUs
}
```

### Regular Expression Validation

Instead of inline patterns, Houp uses **imported regexp variables** for better performance:

**Step 1:** Define regexp in a shared package:

```go
package validators

import "regexp"

var EmailPattern = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
var PhonePattern = regexp.MustCompile(`^\+?[1-9]\d{1,14}$`)
```

**Step 2:** Reference in struct tags:

```go
type Contact struct {
    Email string `validate:"required,regexp=github.com/myorg/validators:EmailPattern"`
    Phone string `validate:"omitempty,regexp=github.com/myorg/validators:PhonePattern"`
}
```

**Generated code:**

```go
import (
    "fmt"
    validators "github.com/myorg/validators"
)

func (c *Contact) Validate() error {
    if c.Email == "" {
        return fmt.Errorf("field Email is required")
    }
    if !validators.EmailPattern.MatchString(c.Email) {
        return fmt.Errorf("field Email does not match required pattern")
    }
    // ...
}
```

### Custom Validators

Define custom validation functions:

```go
package validators

import "fmt"

// Custom validator signature: func(T) error
func ValidatePrice(price float64) error {
    if price < 0 {
        return fmt.Errorf("price cannot be negative")
    }
    if price > 1000000 {
        return fmt.Errorf("price too high")
    }
    return nil
}
```

Use in struct tags:

```go
type Product struct {
    Price float64 `validate:"github.com/myorg/validators:ValidatePrice"`
}
```

## CLI Usage

```bash
houp [options] <package-path>
```

### Options

- `--suffix string` - Suffix for generated files (default: `_validate`)
  ```bash
  houp --suffix=_gen ./models
  ```

- `--overwrite` - Overwrite existing generated files (default: `true`)
  ```bash
  houp --overwrite=false ./models
  ```

- `--dry-run` - Show what would be generated without writing files
  ```bash
  houp --dry-run ./models
  ```

- `--unknown-tags=[fail|skip]` - How to handle unknown validation tags (default: `fail`)
  ```bash
  # Fail on unknown tags (default)
  houp --unknown-tags=fail ./models
  
  # Skip unknown tags with warning
  houp --unknown-tags=skip ./models
  ```

- `--version` - Show version information
  ```bash
  houp --version
  ```

- `--help` - Show help message

### Examples

```bash
# Show version
houp --version

# Generate validation for a package
houp ./models

# Dry run to preview
houp --dry-run ./models

# Use custom suffix
houp --suffix=_validation ./models

# Skip unknown tags
houp --unknown-tags=skip ./models

# Generate for multiple packages
houp ./models ./dto ./api
```

## File Organization

Houp generates one validation file per source file:

```
models/
├── user.go              # Your source
├── user_validate.go     # Generated
├── product.go           # Your source
├── product_validate.go  # Generated
└── order.go             # No validation tags
    (no order_validate.go generated)
```

Generated files:
- Have the same package name as source
- Are named `<filename>_validate.go` (or custom suffix)
- Contain a header comment: `// Code generated by houp. DO NOT EDIT.`
- Should be committed to version control

## Type Support

### Numeric Types
All numeric validations (`min`, `max`, `gt`, `lt`, `gte`, `lte`) support:
- Integers: `int`, `int8`, `int16`, `int32`, `int64`
- Unsigned: `uint`, `uint8`, `uint16`, `uint32`, `uint64`
- Floats: `float32`, `float64`

### String Validation
- `required` - Not empty string
- `min`/`max` - String length
- `regexp` - Pattern matching

### Slice Validation
- `required` - Not nil and not empty
- `min`/`max` - Element count
- `unique` - No duplicate values
- `dive` - Validate each element

### Pointer Validation
- `required` - Not nil
- `omitempty` - Only validate if not nil
- All other validators work on dereferenced value

### Struct Validation
- `dive` - Call `.Validate()` on nested struct
- Works with direct fields, pointers, and slices

## Advanced Use Cases

### Multi-Level Nesting

```go
type Company struct {
    Name      string    `validate:"required"`
    Employees []Person  `validate:"min=1,dive"`
    HQ        *Address  `validate:"required,dive"`
}

type Person struct {
    Name    string   `validate:"required"`
    Address *Address `validate:"required,dive"`
}

type Address struct {
    Street string `validate:"required"`
    City   string `validate:"required"`
}
```

### Complex Combinations

```go
type ComplexValidation struct {
    Username string   `validate:"required,min=3,max=20"`
    Age      *int     `validate:"omitempty,gte=18,lte=100"`
    Tags     []string `validate:"required,min=1,max=10,unique"`
    Profile  *Profile `validate:"required,dive"`
    Items    []Item   `validate:"min=1,dive,unique=Code"`
}
```

### Optional Fields with Validation

Use `omitempty` to skip validation when field is empty:

```go
type OptionalFields struct {
    // Only validate if not empty
    Bio       string  `validate:"omitempty,max=500"`
    Age       *int    `validate:"omitempty,gte=18"`
    Tags      []string `validate:"omitempty,min=1,unique"`
}
```

## Testing

Run the test suite:

```bash
# Run all tests
go test ./...

# Run with coverage
go test -cover ./...

# Update golden files
go test ./pkg/generator -update
```

## Project Structure

```
houp/
├── cmd/
│   └── houp/
│       └── main.go              # CLI entry point
├── pkg/
│   └── generator/
│       ├── types.go             # Core type definitions
│       ├── parser.go            # AST parsing
│       ├── validator.go         # Validation rules
│       ├── codegen.go           # Code generation
│       ├── generator.go         # Package orchestrator
│       └── generator_test.go    # Integration tests
├── internal/
│   └── testutil/
│       └── golden.go            # Golden file helpers
├── testdata/
│   ├── input/                   # Test inputs
│   └── golden/                  # Expected outputs
├── go.mod
├── go.sum
└── README.md
```

## Contributing

Contributions are welcome! Please:

1. Fork the repository
2. Create a feature branch
3. Add tests for new functionality
4. Ensure all tests pass
5. Submit a pull request

## Limitations

- **Unique field constraint:** Fields used in `unique=FieldName` must be of type `string`
- **Custom validators:** Must have signature `func(T) error`
- **Cross-package validation:** Requires generated validation in all referenced packages
- **Regex validation:** Only works with string types (silently skipped for others)

## Performance

Houp generates static code with:
- ✅ Zero reflection overhead
- ✅ Pre-compiled regular expressions
- ✅ Fail-fast validation (returns on first error)
- ✅ Minimal allocations

Benchmark comparisons vs reflection-based validators show 10-100x performance improvement.

## License

MIT License - see LICENSE file for details

## Acknowledgments

- Inspired by `go-playground/validator` but with static code generation
- Uses `golang.org/x/tools/go/packages` for robust AST parsing
- Built with Go 1.18+ generics support

## FAQ

**Q: Do I commit generated files?**  
A: Yes, commit generated `*_validate.go` files to version control.

**Q: Can I customize error messages?**  
A: Currently no, but planned for future release.

**Q: Does it support context-aware validation?**  
A: No, validations are stateless. Use custom validators for context-dependent logic.

**Q: Can I use with existing validator tags?**  
A: No, Houp uses its own `validate` tag. You can run both validators if needed.

**Q: How do I validate maps?**  
A: Map validation is limited to `required` check. Use custom validators for advanced map validation.

**Q: Can I generate validation in a different package?**  
A: No, generated code is always in the same package as the source structs.

## Links

- GitHub: https://github.com/n10ty/houp
- Issues: https://github.com/n10ty/houp/issues
- Documentation: https://github.com/n10ty/houp/wiki
